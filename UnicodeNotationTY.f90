!
!  UnicodeNotationTY.f90 - This module contains definitions of the UnicodeNotation class
!
!  Generated by the Visual Fortran COM Server Wizard on
!  06/20/08 at 11:42:58.
!
!   DO NOT EDIT THIS FILE!
!
!  This file is re-generated every time the object hierarchy is changed.
!

module UnicodeNotation_Types

    use UnicodeNotation_USE
    use dfwinty

    !  Strings used in registering class
    character*22, parameter :: UnicodeNotation_CLASS_NAME = ("UnicodeNotation Class")
    character*20, parameter :: UnicodeNotation_PROGID = ("BOUN.UnicodeNotation")
    character*3,  parameter :: UnicodeNotation_VERSION = ("1.0")
    character*10, parameter :: UnicodeNotation_THREADING_MODEL = ("APARTMENT")

    ! CLSIDs        
    TYPE (GUID), PARAMETER :: CLSID_UnicodeNotation = &
        GUID(#98B8D06B, #2D37, #46A8, &
        CHAR('94'X)//CHAR('5B'X)//CHAR('77'X)//CHAR('1E'X)// &
        CHAR('A4'X)//CHAR('F5'X)//CHAR('63'X)//CHAR('1C'X))
                                                
    ! IIDs      
    ! Per Interface
    TYPE (GUID), PARAMETER :: IID_IUnicodeNotation = &
        GUID(#7F6C35E3, #F2AA, #41F3, &
        CHAR('8B'X)//CHAR('65'X)//CHAR('45'X)//CHAR('2E'X)// &
        CHAR('50'X)//CHAR('E2'X)//CHAR('34'X)//CHAR('FE'X))

    !  This is the per-instance data of the class
    ! Per Interface
    type IUnicodeNotation_Ptr
        sequence
        type (IUnicodeNotation_Vtbl), pointer :: pVtbl
        type (UnicodeNotation_InternalData), pointer :: pInternalData
    end type IUnicodeNotation_Ptr

    type UnicodeNotation_InternalData
        sequence
        type (UnicodeNotation_InstanceData), pointer :: pInstanceData
        type (UnicodeNotation_Data), pointer :: pStart
        integer refCount
    end type UnicodeNotation_InternalData

    type UnicodeNotation_Data
        sequence
    ! Per Interface
        type (IUnicodeNotation_ptr) IUnicodeNotation_InternalData
        type (UnicodeNotation_InternalData) InternalData
    end type UnicodeNotation_Data

    ! Per Interface
    !  All methods must return integer(LONG) (an HRESULT)
    !  All methods must take as their first argument, the instance
    !  data type by reference
    type IUnicodeNotation_Vtbl
        sequence
        ! IUnknown Methods
        integer(INT_PTR_KIND()) QueryInterface
        integer(INT_PTR_KIND()) AddRef
        integer(INT_PTR_KIND()) Release
        ! IDispatch Methods
        integer(INT_PTR_KIND()) GetTypeInfoCount
        integer(INT_PTR_KIND()) GetTypeInfo
        integer(INT_PTR_KIND()) GetIDsOfNames
        integer(INT_PTR_KIND()) Invoke
        !  IUnicodeNotation Methods
        integer(INT_PTR_KIND()) Notate
        integer(INT_PTR_KIND()) get_Coalesce
        integer(INT_PTR_KIND()) put_Coalesce
        integer(INT_PTR_KIND()) Generate
    end type IUnicodeNotation_Vtbl

  contains

    !  IUnknown implementation for all interfaces of the class

    function UnicodeNotation_QueryInterface (pData, riid, ppv) result (r)
    !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_QueryInterface
        use dfwinty
        use dfcom
        implicit none

        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        type(GUID), INTENT(IN) :: riid
        !dec$ attributes reference :: riid
        integer(INT_PTR_KIND()), INTENT(OUT) :: ppv
        !dec$ attributes reference :: ppv
        integer(LONG) r

        r = S_OK
        ppv = NULL

        !  Ensure that they are requesting a supported interface
        !  NOTE:  All requests for IUnknown MUST return the same pointer (per COM)
        if (COMIsEqualGUID(riid, IID_IUnknown)) then
            ppv = loc(pData % pInternalData % pStart % IUnicodeNotation_InternalData)
        !  Per interface
        else if (COMIsEqualGUID(riid, IID_IUnicodeNotation)) then
            ppv = loc(pData % pInternalData % pStart % IUnicodeNotation_InternalData)
        else if (COMIsEqualGUID(riid, IID_IDispatch)) then
            ppv = loc(pData % pInternalData % pStart % IUnicodeNotation_InternalData)
        end if

        if (ppv == NULL) then
            r = E_UNEXPECTED 
            return
        end if

        pData % pInternalData % refCount = &
            pData % pInternalData % refCount + 1

    end function 

    function UnicodeNotation_AddRef (pData) result (r)
    !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_AddRef
        use dfwinty
        implicit none

        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        integer r

        pData % pInternalData % refCount = &
            pData % pInternalData % refCount + 1
        r = pData % pInternalData % refCount

    end function 

    function UnicodeNotation_Release (pData) result (r)
    !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_Release
        use dfwinty
        use BOUN_global
        implicit none

        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        integer r

        type (UnicodeNotation_Data),  pointer :: pUnicodeNotationData
        integer status

        pData % pInternalData % refCount = &
            pData % pInternalData % refCount - 1
        r = pData % pInternalData % refCount
        if (pData % pInternalData % refCount == 0) then
            !  Time to delete ourself....
            pUnicodeNotationData => pData % pInternalData % pStart
            !  Call the "destructor"
            call UnicodeNotation_DESTRUCTOR(pUnicodeNotationData % InternalData % pInstanceData)
            !  Per interface
            deallocate (pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl)
            deallocate (pUnicodeNotationData % InternalData % pInstanceData)
            deallocate (pUnicodeNotationData)
            status = ServerUnlock()
        end if

    end function 


    !  IDispatch implementation for IUnicodeNotation

    function UnicodeNotation_GetTypeInfoCount(pData, pctinfo) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_GetTypeInfoCount
        implicit none
        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        integer(LONG), INTENT(OUT) :: pctinfo
        !dec$ attributes reference :: pctinfo
        integer(LONG) hresult

        hresult = S_OK
        pctinfo = 1

    end function

    function UnicodeNotation_GetTypeInfo(pData, iTInfo, lcid, ppTInfo) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_GetTypeInfo
        use dfwinty
        use BOUN_global
        use kernel32
        use oleaut32
        use dfcom
        implicit none
        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        integer, INTENT(IN) :: iTInfo
        !dec$ attributes value :: iTInfo
        integer, INTENT(IN) :: lcid
        !dec$ attributes value :: lcid
        integer(INT_PTR_KIND()), INTENT(OUT) :: ppTInfo
        !dec$ attributes reference :: ppTInfo
        integer(LONG) hresult

        interface
            function GetTypeInfoOfGuid(pITypeLib, rguid, ppTInfo) result (hresult)
            !DEC$ ATTRIBUTES DEFAULT :: GetTypeInfoOfGuid
            !DEC$IF DEFINED(_X86_)
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'_GetTypeInfoOfGuid@8' :: GetTypeInfoOfGuid
            !DEC$ ELSE
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'GetTypeInfoOfGuid' :: GetTypeInfoOfGuid
            !DEC$ ENDIF
                use dfwinty
                integer(INT_PTR_KIND()) pITypeLib
                !dec$ attributes value :: pITypeLib
                TYPE (GUID), INTENT(IN) :: rguid 
                !dec$ attributes reference :: rguid
                integer(INT_PTR_KIND()), INTENT(OUT) :: ppTInfo
                !dec$ attributes reference :: ppTInfo
                integer(LONG) hresult
            end function
        end interface
		POINTER(GetTypeInfoOfGuid_PTR, GetTypeInfoOfGuid)	! routine pointer

        integer(INT_PTR_KIND()) pITypeLib    ! ITypeLib*
		INTEGER(INT_PTR_KIND()) $VTBL		 ! ITypeLib Function Table
		POINTER($VPTR, $VTBL)
        integer res

        hresult = S_OK
        if (iTInfo /= 0) then
            hresult = TYPE_E_ELEMENTNOTFOUND
            return
        end if
        ppTInfo = gUnicodeNotationITypeInfo
        
        !  Get the type information if we don't already have it
        !  NOTE:  This code will always return the ITypeInfo of the
        !         first LCID that is found
        if (gUnicodeNotationITypeInfo == NULL) then
            call EnterCriticalSection(loc(gGlobalCriticalSection))
            if (gUnicodeNotationITypeInfo == NULL) then
                hresult = LoadRegTypeLib(GUID_TypeLib_BOUN, 1, 0, lcid, pITypeLib)
                if (hresult < 0) then
                    call LeaveCriticalSection(loc(gGlobalCriticalSection))
                    return
                end if
				$VPTR = pITypeLib
				$VPTR = $VTBL + (6 * INT_PTR_KIND()) ! Add GetTypeInfoOfGuid routine offset
				GetTypeInfoOfGuid_PTR = $VTBL
                hresult = GetTypeInfoOfGuid(pITypeLib, IID_IUnicodeNotation, gUnicodeNotationITypeInfo)
                res = COMReleaseObject(pITypelib)
                if (hresult < 0) then
                    call LeaveCriticalSection(loc(gGlobalCriticalSection))
                    return
                end if
            end if
            call LeaveCriticalSection(loc(gGlobalCriticalSection))
            ppTInfo = gUnicodeNotationITypeInfo
        end if
        res = COMAddObjectReference(gUnicodeNotationITypeInfo)

    end function

    function UnicodeNotation_GetIDsOfNames(pData, riid, rgszNames, cNames, lcid, rgDispID) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_GetIDsOfNames
        use dfwinty
        use BOUN_global
        use dfcom
        implicit none
        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        TYPE (GUID), INTENT(IN)    :: riid 
        !dec$ attributes reference :: riid
        integer(INT_PTR_KIND()), INTENT(IN) :: rgszNames
        !dec$ attributes value :: rgszNames
        integer, INTENT(IN) :: cNames
        !dec$ attributes value :: cNames
        integer, INTENT(IN) :: lcid
        !dec$ attributes value :: lcid
        integer(LONG), DIMENSION(:), INTENT(OUT) :: rgDispID
        !dec$ attributes reference :: rgDispID
        integer(LONG) hresult

        interface
            function DispGetIDsOfNames(pITypeInfo, rgszNames, cNames, rgDispID) result (hresult)
            !DEC$ ATTRIBUTES DEFAULT :: DispGetIDsOfNames
            !DEC$IF DEFINED(_X86_)
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'_DispGetIDsOfNames@16' :: DispGetIDsOfNames
            !DEC$ ELSE
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'DispGetIDsOfNames' :: DispGetIDsOfNames
            !DEC$ ENDIF
                use dfwinty
                integer(INT_PTR_KIND()) pITypeInfo
                !dec$ attributes value :: pITypeInfo
                integer(INT_PTR_KIND()), INTENT(IN) :: rgszNames
                !dec$ attributes value :: rgszNames
                integer, INTENT(IN) :: cNames
                !dec$ attributes value :: cNames
                integer(LONG), DIMENSION(:), INTENT(OUT) :: rgDispID
                !dec$ attributes reference :: rgDispID
                integer(LONG) hresult
            end function
        end interface

   		TYPE (GUID), PARAMETER :: IID_NULL = &
			GUID(#00000000, #0000, #0000, &
			  CHAR('00'X)//CHAR('00'X)//CHAR('00'X)//CHAR('00'X)// &
			  CHAR('00'X)//CHAR('00'X)//CHAR('00'X)//CHAR('00'X))
        integer(INT_PTR_KIND()) pTInfo 
        integer res

        hresult = S_OK

        !  The riid argument must be IID_NULL
        if (.not. COMIsEqualGUID(riid, IID_NULL)) then
            hresult = DISP_E_UNKNOWNINTERFACE
            return
        end if

        !  Get the ITypeInfo pointer
        hresult = UnicodeNotation_GetTypeInfo(pData, 0, lcid, pTInfo)
        if (hresult < 0) return

        !  Call DispGetIDsOfNames
        hresult = DispGetIDsOfNames(pTInfo, rgszNames, cNames, rgDispID)
        res = COMReleaseObject(pTInfo)

    end function

    function UnicodeNotation_Invoke(pData, dispidMember, riid, lcid, &
        wFlags, pparams, pvarResult, pexcepinfo, puArgErr) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: UnicodeNotation_Invoke
        use dfwinty
        use BOUN_global
        use dfcom
        implicit none
        type (IUnicodeNotation_Ptr) pData
        !dec$ attributes reference :: pData
        integer(LONG), INTENT(IN) :: dispidMember
        !dec$ attributes value :: dispidMember
        TYPE (GUID), INTENT(IN)    :: riid 
        !dec$ attributes reference :: riid
        integer, INTENT(IN) :: lcid
        !dec$ attributes value :: lcid
        integer(2), INTENT(IN) :: wFlags
        !dec$ attributes value :: wFlags
        TYPE(T_DISPPARAMS), INTENT(INOUT) :: pparams
        !dec$ attributes reference :: pparams
        TYPE(VARIANT), INTENT(OUT) :: pvarResult
        !dec$ attributes reference :: pvarResult
        TYPE(T_EXCEPINFO), INTENT(OUT) :: pexcepinfo
        !dec$ attributes reference :: pexcepinfo
        integer, INTENT(OUT) :: puArgErr
        !dec$ attributes reference :: puArgErr
        integer(LONG) hresult

        interface
            function DispInvoke(pInterface, pTInfo, dispidMember, &
                wFlags, pparams, pvarResult, pexcepinfo, puArgErr) result (hresult)
            !DEC$ ATTRIBUTES DEFAULT :: DispInvoke
            !DEC$IF DEFINED(_X86_)
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'_DispInvoke@32' :: DispInvoke
            !DEC$ ELSE
            !DEC$ ATTRIBUTES STDCALL, ALIAS:'DispInvoke' :: DispInvoke
            !DEC$ ENDIF
                use dfwinty
                integer(INT_PTR_KIND()) pInterface
                !dec$ attributes value :: pInterface
                integer(INT_PTR_KIND()) pTInfo
                !dec$ attributes value :: pTInfo
                integer(LONG), INTENT(IN) :: dispidMember
                !dec$ attributes value :: dispidMember
                integer(2), INTENT(IN) :: wFlags
                !dec$ attributes value :: wFlags
                TYPE(T_DISPPARAMS), INTENT(INOUT) :: pparams
                !dec$ attributes reference :: pparams
                TYPE(VARIANT), INTENT(OUT) :: pvarResult
                !dec$ attributes reference :: pvarResult
                TYPE(T_EXCEPINFO), INTENT(OUT) :: pexcepinfo
                !dec$ attributes reference :: pexcepinfo
                integer, INTENT(OUT) :: puArgErr
                !dec$ attributes reference :: puArgErr
                integer(LONG) hresult
            end function
        end interface

   		TYPE (GUID), PARAMETER :: IID_NULL = &
			GUID(#00000000, #0000, #0000, &
			  CHAR('00'X)//CHAR('00'X)//CHAR('00'X)//CHAR('00'X)// &
			  CHAR('00'X)//CHAR('00'X)//CHAR('00'X)//CHAR('00'X))
        integer(INT_PTR_KIND()) pTInfo 
        integer res

        hresult = S_OK

        !  The riid argument must be IID_NULL
        if (.not. COMIsEqualGUID(riid, IID_NULL)) then
            hresult = DISP_E_UNKNOWNINTERFACE
            return
        end if

        !  Get the ITypeInfo pointer
        hresult = UnicodeNotation_GetTypeInfo(pData, 0, lcid, pTInfo)
        if (hresult < 0) return

        !  Call DispInvoke
        hresult = DispInvoke(loc(pdata), pTInfo, dispidMember, &
                wFlags, pparams, pvarResult, pexcepinfo, puArgErr)
        res = COMReleaseObject(pTInfo)

    end function

end module



