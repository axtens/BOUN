!
!  @GLOBAL.SOURCE@ - This module contains the interfaces of methods 
!  of the @INTERFACE.NAME@ interface
!
!  Generated by the Visual Fortran COM Server Wizard on
!  @GLOBAL.DATE@ at @GLOBAL.TIME@.
!
!   DO NOT EDIT THIS FILE!
!
!  This file is re-generated every time the object hierarchy is changed.
!

module @INTERFACE.NAME@_Methods

@#IFANY METHOD
    !  These routines get implemented by the user
    interface 
        @#PER METHOD
        function @INTERFACE.NAME@_@METHOD.NAME@( ObjectData@#IFANY ARGUMENT ,@#ENDIF &
                @#PER ARGUMENT @ARGUMENT.NAME@@#PERPOSTFIX ",&
                "@#ENDPER ) result (hresult)
            use @CLASS.NAME@_Types
            type(@CLASS.$INSTANCENAME@) ObjectData
            !dec$ attributes reference :: ObjectData
            @#PER ARGUMENT
            @(= FortDefinition(ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL)@) :: @ARGUMENT.NAME@@[
            @(= FortDimension2(ARGUMENT.NAME, ARGUMENT.ARRAY, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@)@]
            @#ENDPER
            integer(LONG) hresult
        end function
        @#ENDPER

    end interface

    !  Local definition of SysStringLen
    interface
        PURE INTEGER*4 FUNCTION SysStringLen_Local(bstr);
            !DEC$IF DEFINED(_X86_)
            !DEC$ ATTRIBUTES DEFAULT, STDCALL, ALIAS : '_SysStringLen@' :: SysStringLen_Local
            !DEC$ELSE
            !DEC$ ATTRIBUTES DEFAULT, STDCALL, ALIAS : 'SysStringLen' :: SysStringLen_Local
            !DEC$ENDIF
            USE DFWINTY
            INTEGER(INT_PTR_KIND()), INTENT(IN)    :: bstr
            !DEC$ ATTRIBUTES VALUE              :: bstr
        END FUNCTION SysStringLen_Local
    end interface

  contains

    !  Wrapper functions called from the Vtbl

    @#PER METHOD
    function $@INTERFACE.NAME@_@METHOD.NAME@( pInterface@#IFANY ARGUMENT ,@#ENDIF &
            @#PER ARGUMENT @ARGUMENT.NAME@ @#PERPOSTFIX ",&
            "@#ENDPER	) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $@INTERFACE.NAME@_@METHOD.NAME@
        use @CLASS.NAME@_Types
        use dfcom
        use dflib
        implicit none
        type (@INTERFACE.NAME@_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        @#PER ARGUMENT
        @(= FortTypeToFortInterfaceType(ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL)@) :: @ARGUMENT.NAME@ 
        @[!DEC$ ATTRIBUTES @(= PassMechanism(ARGUMENT.INTENT, ARGUMENT.BYREF)@) :: @ARGUMENT.NAME@ @]
        @#ENDPER
        integer(LONG) hresult
        integer i
        @#PER ARGUMENT
        @(= GetCallTemp2(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@) @#ENDPER
        @#PER ARGUMENT
        @(= CallTempInit2(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@) @#ENDPER
        @#PER ARGUMENT
        @(= PreCall2(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@) @#ENDPER
		@($OPTCONTEXT = OptCallBegin()@)
        @#PER ARGUMENT
@[        if (p$@ARGUMENT.NAME@ == .FALSE.) then
            hresult = @INTERFACE.NAME@_@METHOD.NAME@(pInterface % pInternalData % pInstanceData@(= OptCall(METHOD.$OPTCONTEXT, ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL)@)
        else@]@#ENDPER

        hresult = @INTERFACE.NAME@_@METHOD.NAME@(pInterface % pInternalData % pInstanceData@#IFANY ARGUMENT ,@#ENDIF &
            @#PER ARGUMENT @(= GetCallName(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL)@) @#PERPOSTFIX ",&
            "@#ENDPER )
        @(= OptCallFinish(METHOD.$OPTCONTEXT)@)
        if (hresult < 0) goto 9999
        @#PER ARGUMENT
        @(= PostCallOut2(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@) @#ENDPER
    9999  continue  ! Cleanup code
        @#PER ARGUMENT
        @(= PostCallClean2(ARGUMENT.NAME, ARGUMENT.DATATYPE, ARGUMENT.INTENT, ARGUMENT.ARRAY, ARGUMENT.OPTIONAL, ARGUMENT.RANK, ARGUMENT.ASSUMEDSHAPE, ARGUMENT.LB1, ARGUMENT.UB1, ARGUMENT.LB2, ARGUMENT.UB2, ARGUMENT.LB3, ARGUMENT.UB3, ARGUMENT.LB4, ARGUMENT.UB4, ARGUMENT.LB5, ARGUMENT.UB5, ARGUMENT.LB6, ARGUMENT.UB6, ARGUMENT.LB7, ARGUMENT.UB7)@) @#ENDPER
    end function
    @#ENDPER
@#ENDIF
end module

