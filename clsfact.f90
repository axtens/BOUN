!
!  clsfact.f90 - This file contains methods of the IClassFactory 
!  interface that is used to create instances of the user's classes
!
!  Generated by the Visual Fortran COM Server Wizard on
!  06/20/08 at 11:42:58.
!
!   DO NOT EDIT THIS FILE!
!
!  This file is re-generated every time the object hierarchy is changed.
!

function IClassFactory_QueryInterface (pData, riid, ppv) result (r)
!DEC$ ATTRIBUTES STDCALL :: IClassFactory_QueryInterface
    use IClassFactory_Types
    use dfwinty
    use dfcom
    use kernel32
    implicit none

    type (IClassFactory_Data) pData
	!dec$ attributes reference :: pData
    type(GUID) riid
	!dec$ attributes reference :: riid
    integer(INT_PTR_KIND()) ppv
	!dec$ attributes reference :: ppv
    integer(LONG) r

    integer(LONG) i

    r = S_OK

    !  Ensure that they are requesting 
    !  the IClassFactory or IUnknown interface
    if ((.not. COMIsEqualGUID(riid, IID_IClassFactory)) .AND. &
        (.not. COMIsEqualGUID(riid, IID_IUnknown))) then
        r = E_UNEXPECTED 
        return
    end if

    i = InterlockedIncrement (loc(pData % refCount)) 
    ppv = loc(pData)

end function 

function IClassFactory_AddRef (pData) result (r)
!DEC$ ATTRIBUTES STDCALL :: IClassFactory_AddRef
    use IClassFactory_Types
    use dfwinty
    use kernel32
    implicit none

    type (IClassFactory_Data) pData
	!dec$ attributes reference :: pData
    integer r

    integer(LONG) i

    i = InterlockedIncrement (loc(pData % refCount)) 
    r = pData % refCount

end function 

function IClassFactory_Release (pData) result (r)
!DEC$ ATTRIBUTES STDCALL :: IClassFactory_Release
    use IClassFactory_Types
    use dfwinty
    use BOUN_global
    use kernel32
    implicit none

    type (IClassFactory_Data), target :: pData
	!dec$ attributes reference :: pData
    integer r

    type (IClassFactory_Data),  pointer :: pCFData
    integer status

    call EnterCriticalSection(loc(gGlobalCriticalSection))
    pData % refCount = pData % refCount - 1
    r = pData % refCount
    if (pData % refCount == 0) then
        !  Time to delete ourself....
        deallocate (pData % pVtbl)
        pCFData => pData
        deallocate (pCFData)
        !status = ServerUnlock()
    end if
    call LeaveCriticalSection(loc(gGlobalCriticalSection))

end function 

function IClassFactory_LockServer (pData, bLock) result (r)
!DEC$ ATTRIBUTES STDCALL :: IClassFactory_LockServer
    use IClassFactory_Types
    use dfwinty
    use BOUN_global
    implicit none

    type (IClassFactory_Data) pData
	!dec$ attributes reference :: pData
    logical bLock
	!dec$ attributes value :: bLock
    integer(LONG) r

    integer status

    r = S_OK

    if (bLock) then
        status = ServerLock()
    else
        status = ServerUnlock()
    end if

end function 

!  Per class
function IClassFactory_CreateUnicodeNotationInstance (pData, pUnk, riid, ppv) result (r)
!DEC$ ATTRIBUTES STDCALL :: IClassFactory_CreateUnicodeNotationInstance
    use IClassFactory_Types
    use dfwinty
    use dfcom
    use BOUN_global
    use UnicodeNotation_Types
    use IUnicodeNotation_Methods
    implicit none

    type (IClassFactory_Data) pData
	!dec$ attributes reference :: pData
    integer(INT_PTR_KIND()) pUnk
	!dec$ attributes value :: pUnk
    type(GUID) riid
	!dec$ attributes reference :: riid
    integer(INT_PTR_KIND()) ppv
	!dec$ attributes reference :: ppv
    integer(LONG) r

    integer status
    integer(INT_PTR_KIND()) ptr
    type (UnicodeNotation_Data),  pointer :: pUnicodeNotationData

    r = S_OK
    ppv = NULL

    !  Ensure that they are requesting a supported interface
    if ((.not. COMIsEqualGUID(riid, IID_IUnknown)) &
        !  Per interface
         .AND. (.not. COMIsEqualGUID(riid, IID_IUnicodeNotation)) &
         .AND. (.not. COMIsEqualGUID(riid, IID_IDispatch)) &
        ) then
        r = E_UNEXPECTED 
        return
    end if

	!  Class does not support aggregation
	if (pUnk /= NULL) then
        r = CLASS_E_NOAGGREGATION
        return
	endif

    !  Allocate instance data structure and Vtbl
    allocate (pUnicodeNotationData)

    !  Per interface
    allocate (pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % QueryInterface = loc(UnicodeNotation_QueryInterface)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % AddRef = loc(UnicodeNotation_AddRef)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % Release = loc(UnicodeNotation_Release)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % GetTypeInfoCount = loc(UnicodeNotation_GetTypeInfoCount)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % GetTypeInfo = loc(UnicodeNotation_GetTypeInfo)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % GetIDsOfNames = loc(UnicodeNotation_GetIDsOfNames)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % Invoke = loc(UnicodeNotation_Invoke)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % Notate = loc($IUnicodeNotation_Notate)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % get_Coalesce = loc($IUnicodeNotation_get_Coalesce)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % put_Coalesce = loc($IUnicodeNotation_put_Coalesce)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl % Generate = loc($IUnicodeNotation_Generate)
    pUnicodeNotationData % IUnicodeNotation_InternalData % pInternalData => pUnicodeNotationData % InternalData
    pUnicodeNotationData % InternalData % pStart => pUnicodeNotationData
    pUnicodeNotationData % InternalData % refCount = 1

    !  Allocate the user-defined instance data structure
    allocate (pUnicodeNotationData % InternalData % pInstanceData)
    !  Call the "constructor"...
    status = UnicodeNotation_CONSTRUCTOR(pUnicodeNotationData % InternalData % pInstanceData)
    if (status /= S_OK) then
        deallocate (pUnicodeNotationData % InternalData % pInstanceData)
        deallocate (pUnicodeNotationData % IUnicodeNotation_InternalData % pVtbl)
        deallocate (pUnicodeNotationData)
        r = status
        return
    endif

    !  Increment the server's active object count
    status = ServerLock()

    !  Return the correct interface
    if (COMIsEqualGUID(riid, IID_IUnknown)) then
        ppv = loc(pUnicodeNotationData)
    !  Per interface
    else if (COMIsEqualGUID(riid, IID_IUnicodeNotation)) then
        ppv = loc(pUnicodeNotationData % IUnicodeNotation_InternalData)
    else if (COMIsEqualGUID(riid, IID_IDispatch)) then
        ppv = loc(pUnicodeNotationData % IUnicodeNotation_InternalData)
    end if

end function 
